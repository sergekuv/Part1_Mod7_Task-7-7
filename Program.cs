using System;

namespace Part1_Mod7_Task_7_7
{
    //  Базовый уровень:
    //  B1  Использование наследования;                          +  выполнено, например, Person -> Customer 
    //  B2  Использование абстрактных классов или членов класса; +  выполнено, например,  Person -> Customer 
    //  B3  Использование принципов инкапсуляции;                +  надеюсь, что ничего лишнего наружу не выставлено; если ошибаюсь - пишите..
    //  B4  Использование переопределений методов/свойств;       + если имеется в виду перегрузка (override), то она есть, например, у Customer (метод Show())
    //  B5  Использование минимум 4 собственных классов;         + выполнено (классов больше четырех)
    //  B6  Использование конструкторов классов с параметрами;   + например, в классе Address есть такой конструктор
    //  B7  Использование обобщений;                             + в классе Order есть List<Item>()
    //  B8  Использование свойств;                               +  в классе Address есть свойство PostCode
    //  B9  Использование композиции классов.                    +  например, Address и Customer

    //  Продвинутый уровень:
    //  A1  Использование статических элементов или классов;            + например, class Utilities
    //  A2  Использование обобщенных методов;                           + не смог придумать ничего лучше, чем Utilities.ShowAge()
    //  A3  Корректное использование абстрактных классов                + например, Person -> Customer и Person -> Courier
    //  A4  Корректное использование модификаторов элементов класса      
    //  (чтобы важные поля не были доступны.. извне, исп. protected)    + надеюсь, оно корректно, если ошибаюсь - пишите..
    //  A5  Использование свойств с логикой в get и/или set блоках.     + в классе Address есть свойство PostCode, там есть логика в set

    //  Усложненный уровень:
    //  C1  Использование методов расширения;                    + В классе Utilities есть расширяющий метод IsValidEmail, который используется в классе Contact
    //  C2  Использование наследования обобщений;                + не смог придумать ничего лучше.. Person<TAge> -> Customer<TAge>. Совершенно бесполезно, но синтаксис наследования есть..  
    //  C3  Использование агрегации классов;                     + например, Order и Customer 
    //  C4  Использование индексаторов;                          + есть в классе Order
    //  C5  Использование перегруженных операторов.              + в классе Order есть перезгузка оператора "+" 

    class Program
    {
        static void Main(string[] args)
        {
            Customer<int> cust1 = new Customer<int>(age : 18, name : "FirstName", surname : "LastName");    // адрес и контакт добавятся автоматически, для данного примера это, надеюсь, приемлемо
            Product p1 = new Product(pn : "PN0001", name: "product 1", price: 1);
            Product p2 = new Product(pn: "PN0002", name: "product 2", price: 2);
            Order order1 = new Order(cust: cust1, num: "0001");
            order1.AddItem(new Item(pos: 1, prod: p1));
            order1 = order1 + (new Item(pos: 1, prod: p2));
            order1.Show();
            Console.WriteLine("Order item found by index " + order1["PN0002"].Show());

        }
    }
}
